- [Abstract](#abstract)
- [Materials](#materials)
- [Basic](#basic)
	- [Echo String](#echo-string)
	- [Yacc](#yacc)
	- [Stringer](#stringer)

----

# Abstract

go file 의 윗 부분에 특정 comment 를 달아두자. 그리고 `$ go generate ./...` 를 실행하면
특정 comment 가 추가된 go file 들을 읽어들여 각 파일마다 새로운 code 를 생성한다.

# Materials

* [Generating code @ goblog](https://go.dev/blog/generate)
* [Package generate](https://golang.org/pkg/cmd/go/internal/generate/)
* [go generate design document](https://docs.google.com/document/d/1V03LUfjSADDooDMhe-_K59EgpTEm3V8uvQRuNMAEnjg/edit)
  * go generate 을 어떻게 design 했는지 알 수 있다. 또한 design document 작성법을 참고할 만 하다.

# Basic

## Echo String

`$ go generate ./...` 를 실행하면 `"Hello World"` 가 출력되도록 해보자.

> directory

```
.
├── cmd
│   └── main
│       └── main.go
├── go.mod
├── internal
│   └── foo
│       └── hello.go
└── main
```

> `cmd/main/main.go`

```go
package main

import (
	"fmt"

	"iamslash.com/alpha/internal/foo"
)

func main() {
	fmt.Println(foo.HelloWorld())
}
```

> `internal/foo/hello.go`

```go
package foo

// +build ignore
//go:generate echo "Hello World"

func HelloWorld() string {
	return "Hello World"
}
```

> build & generate

```bash
$ go mod init iamslash.com
$ go build ./...
$ go generate
Hello World
```

> Why `// +build ignore` doesn't work ??? 2020.01.31

## Yacc

> [Generating code @ goblog](https://go.dev/blog/generate)

`goyacc` 로 `gopher.y` 를 parsing 하고 go code 를 generate 해보자.

```bash
# Install goyacc
$ go get golang.org/x/tools/cmd/goyacc
# Run goyacc
$ goyacc -o gopher.go -p parser gopher.y
```

이번에는 `$ go generate ./...` 를 실행하면 특정 파일들이 go code 를 생성하도록
해보자. 다음과 같은 comment 를 `gopher.y` 의 윗부분에 추가하자. comment 는
`//go:generate` 와 `<generate-command-line>` 으로 구성된다. `$ go generate ./...` 는 `//go:generate` 으로 시작하는 comment 가 추가된 파일들을 모아서 `<generate-command-line>` 를
실행한다.

```go
//go:generate goyacc -o gopher.go -p parser gopher.y
```

보통 다음과 가튼 방식으로 go code 를 생성하고 build 및 test 한다.

```bash
$ cd $GOPATH/myrepo/gopher
$ go generate
$ go build
$ go test
```

## Stringer

`go generate` 를 이용하여 `String()` 함수 code 를 생성할 수도 있다.  

먼저 `stringer` 를 설치한다.

```bash
$ go get golang.org/x/tools/cmd/stringer
```

다음과 같은 code 가 있다고 해보자.

> * `pill/phill.go`

```go
package painkiller

type Pill int

const (
    Placebo Pill = iota
    Aspirin
    Ibuprofen
    Paracetamol
    Acetaminophen = Paracetamol
)
```

`Phill` 을 디버깅하기 위해 문자열로 출력하는 `Phill::String()` 을 구현해 보자. `Pill`
의 종류가 많지 않기 때문에 다음과 같이 손쉽게 구현할 수 있다. 

```go
func (p Pill) String() string {
    switch p {
    case Placebo:
        return "Placebo"
    case Aspirin:
        return "Aspirin"
    case Ibuprofen:
        return "Ibuprofen"
    case Paracetamol: // == Acetaminophen
        return "Paracetamol"
    }
    return fmt.Sprintf("Pill(%d)", p)
}
```

만약 `Pill` 의 종류가 많아진다고 생각해 보자. `String()` 의 구현은 쉽지 않다.
다음과 같이 `pill/phill.go` 에 generate comment 를 추가하자.

```go
package painkiller

//go:generate stringer -type=Pill

type Pill int

const (
    Placebo Pill = iota
    Aspirin
    Ibuprofen
    Paracetamol
    Acetaminophen = Paracetamol
)
```

그리고 다음을 실행하자. `pill_string.go` 가 생성되었다.

```bash
$ go generate ./...
$ cat pill_string.go
// Code generated by stringer -type Pill pill.go; DO NOT EDIT.

package painkiller

import "fmt"

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"

var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
    if i < 0 || i+1 >= Pill(len(_Pill_index)) {
        return fmt.Sprintf("Pill(%d)", i)
    }
    return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
```

`pill_string` 은 readability 는 떨어진다. 그러나 직접 구현할 수고는
피할 수 있다.
