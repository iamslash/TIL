# Abstract

- GIT을 sourcetree, gitlab와 함께 설명한다.

# Concept

- 게임의 세이브 포인트 처럼 내가 작업 하는 내역들이 저장된다면 얼마나
  좋을까? 현재 작업을 열심히 하면서 만들어진 파일들을 뒤로 하고 
  어제 저장한 세이브 포인트로 한번에 변신할 있다면 얼마나 좋을까?
  그런 고민을 위해서 탄생한 프로그램이 git이다. 물론 git말고도
  무수히 많은 버전 관리 프로그램들이 넘쳐난다. 하지만 대세는
  git이다. 
- git을 개발자들이 공부하는 방식으로 접근하면 다소 러닝 커브가
  높다고 할 수 있다. 하지만 sourtree와 같은 응용 프로그램을
  활용한다면 다소 어렵기만 했던 git을 잘 활용할 수 있다.
  
# Contingency

- 대체 git은 무엇인란 말인가? 간단히 상황극을 설정해서 어떻게 git이
  동작하는지 가볍게 살펴보자. 
- A라는 사람과 B라는 사람이 있다. 그리고 프로젝트 L이 담겨있는
  디렉토리가 있다. 프로젝트 L이 담겨있는 디렉토리는 저 멀리 서버에
  저장되어 있다. 그래야 A와 B는 똑같은 내용을 다운로드 받아서 작업을
  할 것이다.
- A, B는 서버에 담겨 있는 프로젝트 L을 다운로드 받아서 c:\prj\L에
  저장했다.  A는 한국에 있고 B는 미국에 있다. 둘은 메신저로 협업하는
  중이다. 
- A는 매니저로부터 작업지시를 받아 하나의 일을 완성했다. 그것은
  1.png에 모두 담겨있다. 그리고 두번째 작업지시를 받았다. 1.png에
  수정사항을 반영했다.  그런데 매니저로부터 다시 요청이
  날아왔다. 두번째 작업지시는 하지 말았으면 좋겠으니 그전의 1.png에서
  새로운 작업을 해주었으면 좋겠다는 요청 사항이다. A는 난감하다.  예전
  상황으로 돌아갈 방법이 있었으면 좋겠다. git은 이런 요구사항을 정확히
  만족시켜준다.
- A가 먼저 a.png를 저장했다. 그리고 서버에 업로드 했다. B는 A에게 연락
  받고 a.png를 다운로드 했다. 그리고 몇가지 수정을 한 후 서버에 업로드
  했다. 그 사이 A도 a.png를 수정했다. 그리고 몇가지 수정을 한 후
  서버에 업로드 했다. 짜잔 과연 이후에 무슨일이 발생 했을까? A가
  수정한 a.png와 B가 수정한 a.png는 서버에 옳바르게 저장되어 있을까?
  그렇지 않다. B가 마지막에 수정한 a.png가 덮어쓰기 했으므로 A가
  두번째 작업한 내역은 서버의 a.png에 저장되어 있지 않다.  이것을
  충돌했다라고 표현한다. git은 이런 충돌 현상을 해결할 수 잇게 해준다.
- 앞서 언급한 상황극에서 발생한 난감한 상황들은 git에 의해 모두 해결
  가능하다. 어떻게 그럴 수 있을까? 먼저 git 세계관에 등장하는 몇가지 
  주춧돌들을 알아야 한다. 그 주춧돌은 다음과 같다.
  - working directory (작업 저장소)
  - STAGE (대기소)
  - local repository (가까운 저장소)
  - server repository (머나먼 저장소)
- 앞서 언급한 상황극에서 등장했던 프로젝트 L이 저장되어 있는 서버의
  디렉토리를 우리는 server repository라고 한다. 이제부터 우리는 머나먼
  저장소라고 이름붙여 보자. A가 작업한 c:\prj\L은 working
  directory라고 한다. 이제 부터 작업 저장소 라고 부르자. A가 머나먼 저장소로부터
  git을 이용해서 어떻게 어떻게 다운로드 받아서 c:\prj\L에 저장하면 
  c:\prj\L\.git라는 디렉토리가 생성된다. 이것을 local repository라고 한다.
  이제부터 가까운 저장소라고 부르자.
- A가 무언가 작업을 하면 작업 내역은 당연히 작업 저장소에 남겨질
  것이다. 예를 들어 a.png를 만들면 자업 저장소에 a.png가 남게 된다. 이것을
  가까운 저장소에 일단 저장해야 한다. 이것은 마치 게임에서 세이브 포인트에
  내가 작업한 내역을 저장한 것과 같다. 한 발 더 나아가서 B에게 내가 작업한
  내역을 알리려면 머나먼 저장소에 가까운 저장소에 저장했던 것을 업로드 해야 한다.
  이것이 git이 버전관리하는 대강의 흐름이다.

# public key, private key

- public key (공개키)
- private key (개인키)

# TERMS

## CLONE (머나먼 저장소에서 복사하기)

- 컨셉에서 설명한 바와 같이 프로젝트를 시작하려면 머나먼 저장소가 필요합니다.
  우리는 gitlab이란 서비스를 이용해 보기로 하죠. gitlab에서 머나먼 저장소를
  하나 만들어 보아요

- 이제 머나먼 저장소에서 프로젝트를 내려받아서 나만의 작업 장소를
  만들어 봅시다.  이른바 CLONE을 하는 것입니다. 재미있게 상황극을
  해보아요. 내가 작업한 것은 A1이라는 디렉토리에 김대리가 작업한 것은
  A2라는 디렉토리에 CLONE해 봅니다.

## ADD (변경사항 대기시키기)

- A1에 a.png를 추가합시다. 변경사항을 대기시켜 보아요.

## COMMIT (가까운 저장소에 저장하기)
## REVISION (저장 지점)
## PUSH (머나먼 저장소에 저장하기)
## PULL (FETCH, MERGE)
## FETCH (머나먼 저장소에서 내려받아 가까운 저장소에 저장하기)
## MERGE (가까운 저장소에서 작업 장소에 합치기)
## CHECKOUT (변신하기)
## BRANCH (작업 흐름)
## CONFLICT (충돌)

# Install sourcetree

# CLONE

# ADD, COMMIT, STAGE, REVISION

# PUSH

# PULL, FETCH, MERGE

# BRANCH

# CHECKOUT

# CONFLICT, MERGE
