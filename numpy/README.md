



# Basic


## `np.triu`

Return a copy of an array with the elements below the k-th diagonal zeroed. For arrays with ndim exceeding 2, triu will apply to the final two axes.

```py
# numpy.triu(m, k=0)
>>> import numpy as np
>>> np.triu([[1,2,3],[4,5,6],[7,8,9]])
array([[1, 2, 3],
       [0, 5, 6],
       [0, 0, 9]])
>>> np.triu([[1,2,3],[4,5,6],[7,8,9]], k = 1)
array([[0, 2, 3],
       [0, 0, 6],
       [0, 0, 0]])
>>> np.triu([[1,2,3],[4,5,6],[7,8,9]], k=2)
array([[0, 0, 3],
       [0, 0, 0],
       [0, 0, 0]])
>>> np.triu([[1,2,3],[4,5,6],[7,8,9]], k=-1)
array([[1, 2, 3],
       [4, 5, 6],
       [0, 8, 9]])
>>> np.triu([[1,2,3],[4,5,6],[7,8,9]], k=-2)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

## NumPy 배열 인덱싱 및 슬라이싱 규칙

1. **전체 범위 선택 (`:`)**
   - 해당 차원의 모든 요소를 선택합니다.
   - 차원이 유지됩니다.

2. **특정 인덱스 선택**
   - 해당 차원에서 특정 요소를 선택합니다.
   - 선택된 차원이 제거됩니다.

3. **슬라이싱**
   - 부분 범위를 선택할 때 사용합니다 (예: `1:3`, `:5`, `2:`)
   - 차원이 유지되지만 크기가 변경될 수 있습니다.

4. **차원 축소**
   - 특정 인덱스 선택 시 해당 차원이 제거됩니다.
   - 결과 배열의 차원 수가 줄어듭니다.

```py
# 1차원
arr = np.arange(9)
arr[0]   # 0 (첫 번째 요소)
arr[1]   # 1 (두 번째 요소)
arr[-1]  # 8 (마지막 요소)

# 2차원
arr = np.arange(12).reshape((3,4))
# [[ 0,  1,  2,  3],
#  [ 4,  5,  6,  7],
#  [ 8,  9, 10, 11]]

arr[:, 0]   # array([0, 4, 8]) (첫 번째 열)
arr[:, -1]  # array([ 3,  7, 11]) (마지막 열)
# arr[:, 0]: 모든 행(:)의 첫 번째 열(0)을 선택
# arr[:, -1]: 모든 행(:)의 마지막 열(-1)을 선택

# 3차원
arr = np.arange(12).reshape((2,2,3))
# [[[ 0,  1,  2],
#   [ 3,  4,  5]],
#  [[ 6,  7,  8],
#   [ 9, 10, 11]]]

arr[:, 0]      # array([[0, 1, 2],
                #        [6, 7, 8]]) (첫 번째 행 선택)
arr[:, :, 0]   # array([[0, 3],
                #        [6, 9]]) (각 2D 배열의 첫 번째 열)
arr[:, :, -1]  # array([[ 2,  5],
                #        [ 8, 11]]) (각 2D 배열의 마지막 열)

# arr[:, 0]: 모든 깊이(:)의 첫 번째 행(0)을 선택
# arr[:, :, 0]: 모든 깊이와 행(:, :)의 첫 번째 열(0)을 선택
# arr[:, :, -1]: 모든 깊이와 행(:, :)의 마지막 열(-1)을 선택
```
