# Kotlin Keyword

```kotlin
object DataProviderManager {
    fun doit() {
        println("I'm doing it.")
    }
    val hello: String
        get() = "Hello"
}
typealias Alpha = String
interface Base {
    fun print()
}
@JvmInline
value class Password(public val s: String)

fun main() {
	// as
	val a: Number = 10
    var s: Int = a as Int
    val `as` = 3
    println("${`as`}")
    
    // as? safe cast operator
	val a: Number = 10
    var s: Int? = a as? Int
    println("${s}")
    val b: Number? = null
    var t: Int? = b as? Int
    println("${t}")
    
    // in
    println(3 in listOf(1, 2, 3))  // true
    println(3 !in listOf(1, 2, 3))    // false
    println(3 in 1..10)             // true
    println(3 in 10..1)             // false
    println(3 in -10..1)             // false
    val b = when (3) {
        in 1..3 -> true
        else -> false
    }
    println(b) // true
    class Foo<out T>
	class Bar<in T>
    
    // covariant, up-casting
    val fooSub = Foo<Int>()
    val fooSup: Foo<Number> = fooSub 
    // contravariant, down-casting
    val barSup = Bar<Number>()
    val barSub: Bar<Int> = barSup
    // asterisk
    val bazSub: Foo<*> = fooSub
    val bazSup: Foo<*> = fooSup
    
    // is
    println("Hello" is String)
    val a = when ("Hello") {
        is String -> true
        else -> false
    }
    println(a)
    
    // object
	val o = object {
    	val hello = "Hello"
    	val world = "World"
    	// object expressions extend Any, so `override` is required on `toString()`
    	override fun toString() = "$hello $world" 
	}
    println("${o.hello} ${o.world}")
    println("${DataProviderManager.hello}")
    
    // return
    val p = 3
    val s = p ?: return 
    println("........")
    
    // throw
    try {
	    throw RuntimeException()    
    } catch (e: RuntimeException) {
        println(e)
    } finally {
        println("finally")
    }
    
    // typealias
    val alpha : Alpha = "Hello"
    println(alpha)
    
    // typeof, reserved for future use
    println(typeof(alpha).toString())
    
    // Soft keywords
    // by
    class BaseImpl(val x: Int) : Base {
        override fun print() { print(x) }
    }
    class Derived(b: Base) : Base by b   
    // generated by 
    class Derived(b: Base) : Base {
        val b : Base = b
        override fun print() {
            b.print()
        }
    }

    val b = BaseImpl(10)
    val d = Derived(b)
    d.print()

    delegate???    
    field, annotation use-site target
    file,annotation use-site target

    // get
    class Foo() {
        var a : String = "Hello"
        	get() { return field }
        	set(s) { field = s }
        var b : String = "World"
    }
    val foo = Foo()
    foo.a = "Hello"
    println(foo.a)
    
    import
    init
    param, annotation use-site target
    property, annotation use-site target
    receiver, annotation use-site target
    // set
    class Example {
    	@set:[Inject VisibleForTesting]
    	var collaborator: Collaborator
	}
    class Example {
        var collaborator: Collaborator
            @Inject @Collaborator
        	set
    }

    // setparam, annotation use-site target
    // value
    val p = Password("Hello World")
    println(p.s)

    // where
    fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>
        where T : CharSequence,
              T : Comparable<T> {
        return list.filter { it > threshold }.map { it.toString() }
    }
```
